@startuml L2PS DL FIFO Sequence Diagram

skinparam NoteBackgroundColor white
skinparam NoteBorderColor black
skinparam NoteFontColor black
actor sender
participant DlEoHandler
box "Router"
    participant EmFsmRouterWithDelay as fsmRouter
    participant FsmRouterDl as fsmRouterDl
    participant EventRouter as router
    participant Routes as routes
    participant EventForwarder as handler
    queue QueuesDelayedEvents as queues
end box
participant "common::stateMachine::Fsm<QueueDispatcherFsmImpl>" as fsm
participant "platform::EmIf" as platform

sender -> DlEoHandler : receiveCallback(., event, ...)
rnote over DlEoHandler
    q_ctx points to the router
end rnote

DlEoHandler -> fsmRouter : processEvent({event...})
rnote over fsmRouter
    eventToBeDelayed = false
    eventToBeFreed = true
end rnote

opt (event == FifosFlushInd)
    rnote over fsmRouter
        isFifosFlushIndSent = false
    end rnote   
end

alt eventToPassthrough == true
    fsmRouter -> fsmRouterDl : processEvent()
    fsmRouterDl -> router : route()
    router -> routes : route()
    alt CellGroupSetupReq messages
        routes -> handler : handle()
        handler -> fsm : processEvent()
    else other messages
        routes -> handler : handleNotRoutableId()
        handler -> fsm : processEvent()
    end
else eventToPassthrough == false
    fsmRouter -> queues : pushBack(priority)
end

DlEoHandler -> fsmRouter : deleteEvent
opt eventToBeFreed == true
    fsmRouter -> platform : deleteEvent()
end

DlEoHandler -> fsmRouter : processDelayedEvents
opt (not eventFlushForbidden) and (not queuesDelayedEvents.isEmpty)
    loop priority from HighestPriorityEvent to PriorityOfIncomingEvent
        group flushOneFifoQueue
            loop (each priority not in fifoQueuesBlacklist)
                rnote over fsmRouter
                    continue = true
                end rnote  

                opt (isEnoughTimeInSlot) and (continue is true)
                    fsmRouter -> queues : pop(priority)
                    group processDelayedEventFromFifoQueue
                        fsmRouter -> fsmRouterDl : processEvent()
                        fsmRouterDl -> router : route()
                        router -> routes : route()
                        alt routable messages:\n CellGroupSetupReq, CellGroupReconfigReq,\n CellGroupDeleteReq, GetResourceUsageReq, SlotSynchroInd,\n StartSlotSynchroInd, StopSlotSynchroInd, TdMetricOrderResp
                            routes -> handler : handle()
                            handler -> fsm : processEvent()
                        else other not routable messages
                            routes -> handler : handleNotRoutableId()
                            handler -> fsm : processEvent()
                        end                
                        opt eventToBeDelayed
                            fsmRouter -> queues: pushFront(prio)
                        end                    
                    end group
                    
                    Alt isSplitEvent is true                    
                        fsmRouter -> queues: pushFront(prio)                     
                    else isSplitEvent is false
                        fsmRouter -> platform : deleteEvent()
                    end
                end
            end
        end group

        opt (not isOverloaded) and (priority higher than PriorityOfIncomingEvent)
            opt (not isFifosFlushIndSent)
                fsmRouter -> fsmRouter: FifosFlushInd
                rnote over fsmRouter
                    isFifosFlushIndSent = true
                end rnote                   
            end
        end
    end

    loop priority from PriorityOfIncomingEvent +1 to LowestPriorityEvent
        opt (priority not in fifoQueuesBlacklist) and (events in current priority > 0)
            opt (not isFifosFlushIndSent) 
                fsmRouter -> fsmRouter: FifosFlushInd
                rnote over fsmRouter
                    isFifosFlushIndSent = true
                end rnote                   
            end        
        end 
    end
end
@enduml